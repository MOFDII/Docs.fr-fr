---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Compréhension et gestion des événements de durée de vie de connexion dans SignalR | Microsoft Docs
author: pfletcher
description: Cet article décrit comment utiliser les événements exposés par l’API Hubs.
ms.author: aspnetcontent
ms.date: 06/10/2014
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 1b60a8c5db4b77880e31825583a26bdee2a1c07c
ms.sourcegitcommit: b28cd0313af316c051c2ff8549865bff67f2fbb4
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/05/2018
ms.locfileid: "37819572"
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="0cbcd-103">Compréhension et gestion des événements de durée de vie de connexion dans SignalR</span><span class="sxs-lookup"><span data-stu-id="0cbcd-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="0cbcd-104">par [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="0cbcd-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="0cbcd-105">Cet article présente les événements de connexion et déconnexion reconnexion SignalR que vous pouvez gérer et les paramètres de délai d’expiration et keepalive que vous pouvez configurer.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="0cbcd-106">Cet article suppose que vous connaissez déjà des événements de durée de vie de SignalR et de connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="0cbcd-107">Pour une introduction à SignalR, consultez [Introduction à SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="0cbcd-108">Pour obtenir la liste des événements de durée de vie de connexion, consultez les ressources suivantes :</span><span class="sxs-lookup"><span data-stu-id="0cbcd-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="0cbcd-109">Comment gérer les événements de durée de vie de connexion dans la classe de concentrateur</span><span class="sxs-lookup"><span data-stu-id="0cbcd-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="0cbcd-110">Comment gérer les événements de durée de vie de connexion dans les clients JavaScript</span><span class="sxs-lookup"><span data-stu-id="0cbcd-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="0cbcd-111">Comment gérer les événements de durée de vie de connexion dans les clients .NET</span><span class="sxs-lookup"><span data-stu-id="0cbcd-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="0cbcd-112">Versions des logiciels utilisées dans cette rubrique</span><span class="sxs-lookup"><span data-stu-id="0cbcd-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="0cbcd-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="0cbcd-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="0cbcd-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="0cbcd-114">.NET 4.5</span></span>
> - <span data-ttu-id="0cbcd-115">SignalR version 2</span><span class="sxs-lookup"><span data-stu-id="0cbcd-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="0cbcd-116">Versions précédentes de cette rubrique</span><span class="sxs-lookup"><span data-stu-id="0cbcd-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="0cbcd-117">Pour plus d’informations sur les versions antérieures de SignalR, consultez [les Versions antérieures de SignalR](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="0cbcd-118">Questions et commentaires</span><span class="sxs-lookup"><span data-stu-id="0cbcd-118">Questions and comments</span></span>
> 
> <span data-ttu-id="0cbcd-119">Veuillez laisser des commentaires sur la façon dont vous avez apprécié ce didacticiel et ce que nous pouvions améliorer dans les commentaires en bas de la page.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="0cbcd-120">Si vous avez des questions qui ne sont pas directement liées à ce didacticiel, vous pouvez les publier à le [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) ou [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="0cbcd-121">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="0cbcd-121">Overview</span></span>

<span data-ttu-id="0cbcd-122">Cet article contient les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="0cbcd-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="0cbcd-123">Scénarios et la terminologie de durée de vie de connexion</span><span class="sxs-lookup"><span data-stu-id="0cbcd-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="0cbcd-124">Les connexions SignalR, les connexions de transport et les connexions physiques</span><span class="sxs-lookup"><span data-stu-id="0cbcd-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="0cbcd-125">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="0cbcd-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="0cbcd-126">Scénarios de déconnexion de client</span><span class="sxs-lookup"><span data-stu-id="0cbcd-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="0cbcd-127">Scénarios de déconnexion de serveur</span><span class="sxs-lookup"><span data-stu-id="0cbcd-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="0cbcd-128">Paramètres de délai d’expiration et keepalive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="0cbcd-129">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0cbcd-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="0cbcd-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="0cbcd-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="0cbcd-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="0cbcd-132">Comment modifier les paramètres de délai d’expiration et keepalive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="0cbcd-133">Comment informer l’utilisateur de déconnexions</span><span class="sxs-lookup"><span data-stu-id="0cbcd-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="0cbcd-134">Comment reconnecter en continu</span><span class="sxs-lookup"><span data-stu-id="0cbcd-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="0cbcd-135">Comment se déconnecter d’un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="0cbcd-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="0cbcd-136">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="0cbcd-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="0cbcd-137">Liens vers des rubriques de référence de l’API sont à la version de .NET 4.5 de l’API.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="0cbcd-138">Si vous utilisez .NET 4, consultez [la version de .NET 4 des rubriques API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="0cbcd-139">Scénarios et la terminologie de durée de vie de connexion</span><span class="sxs-lookup"><span data-stu-id="0cbcd-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="0cbcd-140">Le `OnReconnected` Gestionnaire d’événements dans un concentrateur SignalR peut exécuter directement après `OnConnected` mais pas après `OnDisconnected` pour un client donné.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="0cbcd-141">Vous pouvez avoir une reconnexion sans une déconnexion parce qu’il existe plusieurs façons dans lequel le mot « connexion » est utilisé dans SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="0cbcd-142">Les connexions SignalR, les connexions de transport et les connexions physiques</span><span class="sxs-lookup"><span data-stu-id="0cbcd-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="0cbcd-143">Cet article fait la distinction entre *les connexions SignalR*, *connexions de transport*, et *connexions physiques*:</span><span class="sxs-lookup"><span data-stu-id="0cbcd-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="0cbcd-144">**Connexion SignalR** fait référence à une relation logique entre un client et une URL de serveur géré par l’API SignalR et identifiée par un ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="0cbcd-145">Les données relatives à cette relation sont gérées par SignalR et sont utilisées pour établir une connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="0cbcd-146">Les extrémités de relation et SignalR supprime les données lorsque le client appelle le `Stop` méthode ou une limite de délai d’expiration est atteint pendant la tentative de SignalR rétablir une connexion de transport perdu.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="0cbcd-147">**Connexion de transport** fait référence à une relation logique entre un client et un serveur géré par une des quatre API transport : WebSockets, événements de serveur a été envoyé, forever frame ou longues d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="0cbcd-148">SignalR utilise le transport API pour créer une connexion de transport, et l’API de transport dépend de l’existence d’une connexion réseau physique pour créer la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="0cbcd-149">La connexion de transport se termine lorsque l’arrête SignalR ou lorsque le transport API détecte que la connexion physique est rompue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="0cbcd-150">**Connexion physique** fait référence aux liens de réseau physique--fils, signaux sans fil, routeurs, etc., qui facilite la communication entre un ordinateur client et un ordinateur serveur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="0cbcd-151">La connexion physique doit être présente afin d’établir une connexion de transport, et une connexion de transport doit être établie afin d’établir une connexion SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="0cbcd-152">Toutefois, avec rupture de la connexion physique ne toujours immédiatement fin à la connexion de transport ou de la connexion SignalR, comme expliqué plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="0cbcd-153">Dans le diagramme suivant, la connexion de SignalR est représentée par l’API des concentrateurs et de la couche de PersistentConnection API SignalR, la connexion de transport est représentée par la couche de Transports et la connexion physique est représentée par les lignes entre le serveur et les clients.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagramme d’architecture de SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="0cbcd-155">Lorsque vous appelez le `Start` méthode dans un client SignalR, vous fournissez le code client SignalR avec toutes les informations nécessaires afin d’établir une connexion à un serveur physique.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="0cbcd-156">Le code client SignalR utilise ces informations pour effectuer une demande HTTP et établir une connexion physique qui utilise l’une des méthodes de transport de quatre.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="0cbcd-157">Si l’échec de la connexion de transport ou le serveur ne parvient pas, la connexion SignalR ne disparaît immédiatement, car le client a toujours les informations nécessaires rétablir automatiquement une nouvelle connexion de transport à la même URL de SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="0cbcd-158">Dans ce scénario, aucune intervention de l’application de l’utilisateur n’est impliquée, et lorsque le code de client SignalR établit une nouvelle connexion de transport, il ne démarre pas une nouvelle connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="0cbcd-159">La continuité de la connexion de SignalR est reflétée dans le fait que l’ID de connexion, qui est créé lorsque vous appelez le `Start` (méthode), ne change pas.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="0cbcd-160">Le `OnReconnected` Gestionnaire d’événements sur le Hub s’exécute lorsqu’une connexion de transport est automatiquement rétablie après avoir été perdues.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="0cbcd-161">Le `OnDisconnected` Gestionnaire d’événements s’exécute à la fin d’une connexion SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="0cbcd-162">Une connexion SignalR peut se terminer par une des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="0cbcd-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="0cbcd-163">Si le client appelle le `Stop` (méthode), un message d’arrêt est envoyé au serveur et client et le serveur interrompt la connexion SignalR immédiatement.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="0cbcd-164">Une fois la connectivité entre le client et le serveur est perdue, le client tente de se reconnecter et le serveur attend que le client se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="0cbcd-165">Si les tentatives de reconnexion échouent et le délai de déconnexion se termine, client et serveur mettre fin à la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="0cbcd-166">Le client cesse toute tentative de reconnexion, et le serveur supprime sa représentation sous forme de la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="0cbcd-167">Si le client cesse de s’exécuter sans avoir l’occasion de vous appeler le `Stop` (méthode), le serveur attend que le client pour vous reconnecter, puis met fin à la connexion SignalR après le délai de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="0cbcd-168">Si le serveur s’arrête en cours d’exécution, le client tente de se reconnecter (recréer la connexion de transport), puis met fin à la connexion SignalR après le délai de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="0cbcd-169">Quand il n’y a aucun problème de connexion, et l’application de l’utilisateur termine la connexion SignalR en appelant le `Stop` (méthode), la connexion de SignalR et la connexion de transport commencer et se terminer en même temps.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="0cbcd-170">Les sections suivantes décrivent plus en détail les autres scénarios.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="0cbcd-171">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="0cbcd-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="0cbcd-172">Connexions physiques peuvent être lentes ou il peut y avoir des interruptions de connectivité.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="0cbcd-173">En fonction de facteurs tels que la longueur de l’interruption, la connexion de transport peut-être être supprimée.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="0cbcd-174">SignalR puis tente de rétablir la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="0cbcd-175">Parfois, la connexion de transport API détecte l’interruption et supprime la connexion de transport, et SignalR découvre immédiatement que la connexion est perdue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="0cbcd-176">Dans d’autres scénarios, la connexion de transport API ni SignalR est informé immédiatement que la connectivité a été perdue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="0cbcd-177">Pour tous les transports, à l’exception d’interrogation longue, le client SignalR utilise une fonction appelée *keepalive* dont vous recherchez une perte de connectivité que l’API de transport ne peut pas détecter.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="0cbcd-178">Pour plus d’informations sur la durée pendant laquelle les connexions d’interrogation, consultez [les paramètres de délai d’expiration et keepalive](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="0cbcd-179">Lorsqu’une connexion est inactive, le serveur envoie régulièrement un paquet persistant au client.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="0cbcd-180">À compter de la date de que cet article est en cours d’écriture, la fréquence par défaut est toutes les 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="0cbcd-181">En écoutant pour ces paquets, les clients peuvent indiquer s’il existe un problème de connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="0cbcd-182">Si un paquet persistant n’est pas reçu lorsque attendu, après un bref instant le client suppose qu’il n’y a des problèmes de connexion telles que la lenteur ou des interruptions.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="0cbcd-183">Si le keepalive est toujours pas reçu après une durée plus longue, le client suppose que la connexion a été supprimée, et il commence la tentative de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="0cbcd-184">Le diagramme suivant illustre les événements de client et serveur qui sont déclenchés dans un scénario classique lorsqu’il existe des problèmes avec la connexion physique qui ne sont pas immédiatement reconnus par le transport API.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="0cbcd-185">Le diagramme s’applique aux circonstances suivantes :</span><span class="sxs-lookup"><span data-stu-id="0cbcd-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="0cbcd-186">Le transport est WebSockets, forever frame ou événements de serveur a été envoyé.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="0cbcd-187">Il existe différentes périodes d’interruption de la connexion réseau physique.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="0cbcd-188">L’API de transport ne devient-elle pas prenant en charge de l’interruption, afin de SignalR s’appuie sur les fonctionnalités de keepalive les détecter.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Déconnexions de transport](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="0cbcd-190">Si le client passe en mode de reconnexion, mais ne peut pas établir une connexion de transport dans la limite de délai d’attente de déconnexion, le serveur met fin à la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="0cbcd-191">Lorsque cela se produit, le serveur exécute le Hub `OnDisconnected` (méthode) et les files d’attente d’un message de déconnexion à envoyer au client dans le cas où le client gère pour vous connecter plus tard.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="0cbcd-192">Si le client puis se reconnecte, il reçoit la commande de déconnexion et appelle le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="0cbcd-193">Dans ce scénario, `OnReconnected` n’est pas exécuté lorsque le client se reconnecte, et `OnDisconnected` n’est pas exécuté lorsque le client appelle `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="0cbcd-194">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-194">The following diagram illustrates this scenario.</span></span>

![Interruptions de transport - délai d’attente du serveur](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="0cbcd-196">Les événements de durée de vie de connexion SignalR qui peuvent être déclenchés sur le client sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="0cbcd-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="0cbcd-197">`ConnectionSlow` événement de client.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="0cbcd-198">Déclenché lorsqu’une proportion prédéfinie de la période de délai d’expiration de keepalive est écoulé depuis le dernier message ou keepalive ping a été reçu.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0cbcd-199">Le délai d’avertissement par défaut keepalive est 2/3 du délai d’expiration de keepalive.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="0cbcd-200">Le délai d’expiration de keepalive étant 20 secondes, l’avertissement se produit dans environ 13 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="0cbcd-201">Par défaut, le serveur envoie les pings de keepalive toutes les 10 secondes, et le client vérifie les pings keepalive sur toutes les 2 secondes (un tiers de la différence entre la valeur de délai d’expiration de keepalive et la valeur d’avertissement de délai d’attente keepalive).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="0cbcd-202">Si le transport API reconnaît une déconnexion, SignalR peut être informé de la déconnexion avant que le délai d’avertissement keepalive passe.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="0cbcd-203">Dans ce cas, le `ConnectionSlow` n'aurait pas été déclenché et SignalR irait directement à la `Reconnecting` événement.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="0cbcd-204">`Reconnecting` événement de client.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="0cbcd-205">Déclenché lorsque l’API de transport détecte que la connexion est perdue, ou (b) le délai d’attente keepalive s’est écoulé depuis le dernier message ou keepalive ping a été reçu.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0cbcd-206">Le code de client SignalR commence la tentative de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="0cbcd-207">Vous pouvez gérer cet événement si vous souhaitez que votre application exécute une action lorsqu’une connexion de transport est perdue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="0cbcd-208">Le délai de conservation par défaut est actuellement de 20 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="0cbcd-209">Si votre code client tente d’appeler une méthode de concentrateur pendant que SignalR est en mode de reconnexion, SignalR va tenter d’envoyer la commande.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="0cbcd-210">La plupart du temps, telles que les tentatives échouent, mais dans certains cas, il peuvent réussir.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="0cbcd-211">Pour les événements de serveur a été envoyé, indéfiniment le frame et durée pendant laquelle les transports d’interrogation, SignalR utilise deux canaux de communication, le client utilise pour envoyer des messages et l’autre qu’elle utilise pour recevoir des messages.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="0cbcd-212">Le canal utilisé pour la réception est celui qui est ouverte en permanence, et c’est celui qui est fermé lorsque la connexion physique est interrompue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="0cbcd-213">Le canal utilisé pour l’envoi reste disponible, par conséquent, si la connectivité physique est rétablie, un appel de méthode à partir du client au serveur peut réussi avant que le canal de réception est rétabli.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="0cbcd-214">La valeur de retour n’est pas reçue jusqu'à ce que SignalR rouvre le canal utilisé pour la réception.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="0cbcd-215">`Reconnected` événement de client.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="0cbcd-216">Déclenché lorsque la connexion de transport est rétablie.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="0cbcd-217">Le `OnReconnected` s’exécute le Gestionnaire d’événements dans le Hub.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="0cbcd-218">`Closed` événement de client (`disconnected` événements dans JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="0cbcd-219">Déclenché lorsque le délai de déconnexion expire pendant que le code de client SignalR tente de se reconnecter après avoir perdu la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="0cbcd-220">La valeur par défaut déconnecter délai d’expiration est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="0cbcd-221">(Cet événement est également déclenché lorsque la connexion se termine parce que le `Stop` méthode est appelée.)</span><span class="sxs-lookup"><span data-stu-id="0cbcd-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="0cbcd-222">Les interruptions de connexion de transport qui ne sont pas détectées par l’API de transport et de ne pas différer la réception des pings keepalive à partir du serveur plus longtemps que le délai d’avertissement keepalive ne peuvent pas entraîner toute connexion déclenchement des événements de durée de vie.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="0cbcd-223">Certains environnements réseau délibérément fermer les connexions inactives, et une autre fonction des paquets keepalive consiste à résoudre ce problème en vous permettant de que ces réseaux savoir qu’une connexion de SignalR est en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="0cbcd-224">Dans les cas extrêmes la fréquence par défaut de keepalive pings sans réponse peut-être pas suffisant pour empêcher les connexions fermées.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="0cbcd-225">Dans ce cas, vous pouvez configurer les pings de keepalive doit être envoyé plus souvent.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="0cbcd-226">Pour plus d’informations, consultez [les paramètres de délai d’expiration et keepalive](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0cbcd-227">**Important**: la séquence d’événements décrites ici n’est pas garantie.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="0cbcd-228">SignalR effectue chaque tentative pour déclencher des événements de durée de vie de connexion de manière prévisible en fonction de ce schéma, mais il existe de nombreuses variations des événements de réseau et dans lequel les infrastructures de communications sous-jacentes telles que les API de transport les gérer de nombreuses façons.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="0cbcd-229">Par exemple, le `Reconnected` événement ne peut pas être déclenché lorsque le client se reconnecte, ou le `OnConnected` gestionnaire sur le serveur peut s’exécuter lorsque la tentative pour établir une connexion échoue.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="0cbcd-230">Cette rubrique décrit uniquement les effets qui seraient normalement produits par certains des circonstances normales.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="0cbcd-231">Scénarios de déconnexion de client</span><span class="sxs-lookup"><span data-stu-id="0cbcd-231">Client disconnection scenarios</span></span>

<span data-ttu-id="0cbcd-232">Dans un navigateur client, le code client SignalR qui gère une connexion SignalR s’exécute dans le contexte de JavaScript d’une page web.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="0cbcd-233">Qui a raison pour laquelle la connexion SignalR a à la fin lorsque vous accédez à partir d’une page à l’autre et ce de pourquoi vous avez plusieurs connexions avec plusieurs ID de connexion si vous vous connectez à partir de plusieurs onglets ou fenêtres du navigateur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="0cbcd-234">Lorsque l’utilisateur ferme une fenêtre de navigateur ou un onglet, ou navigue vers une nouvelle page ou actualise la page, la connexion de SignalR se termine immédiatement, car le code client SignalR gère cet événement de navigateur pour vous et appelle le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="0cbcd-235">Dans ces scénarios, ou dans n’importe quelle plateforme client lorsque votre application appelle la `Stop` (méthode), le `OnDisconnected` Gestionnaire d’événements s’exécute immédiatement sur le serveur et le client déclenche le `Closed` événement (l’événement est nommé `disconnected` dans JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="0cbcd-236">Si une application cliente ou l’ordinateur sur lequel il est exécuté sur tombe en panne ou en veille (par exemple, lorsque l’utilisateur ferme l’ordinateur portable), le serveur n’est pas informé de ce qui est arrivé.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="0cbcd-237">Pour autant que déjà connus du serveur, la perte du client peut être en raison d’une interruption de connectivité et le client essaie de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="0cbcd-238">Par conséquent, dans ces scénarios, le serveur attend pour donner au client une occasion de vous reconnecter, et `OnDisconnected` ne s’exécute pas jusqu'à l’expiration de la période de délai d’attente de déconnexion (environ 30 secondes par défaut).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="0cbcd-239">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-239">The following diagram illustrates this scenario.</span></span>

![Échec de l’ordinateur client](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="0cbcd-241">Scénarios de déconnexion de serveur</span><span class="sxs-lookup"><span data-stu-id="0cbcd-241">Server disconnection scenarios</span></span>

<span data-ttu-id="0cbcd-242">Lorsqu’un serveur est mis hors connexion, il redémarre, échoue, le domaine d’application recycle, etc.--le résultat peut être semblable à une perte de connexion, ou l’API de transport et SignalR peuvent savoir immédiatement que le serveur a disparu, SignalR pourrait commencer tente de se reconnecter sans déclencher la `ConnectionSlow` événement.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="0cbcd-243">Si le client passe en mode de reconnexion et si le serveur récupère ou redémarrages ou un nouveau serveur est mis en ligne avant l’expiration de la période de délai d’attente de déconnexion, le client se reconnectera au serveur restauré ou nouveau.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="0cbcd-244">Dans ce cas, la connexion SignalR continue sur le client et le `Reconnected` événement est déclenché.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="0cbcd-245">Sur le premier serveur, `OnDisconnected` n’est jamais exécutée et sur le nouveau serveur, `OnReconnected` est exécuté même si `OnConnected` n’a jamais été exécutée pour ce client sur ce serveur avant.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="0cbcd-246">(L’effet est le même si le client se reconnecte au serveur même après un recyclage de domaine d’application ou de redémarrage, car lorsque le serveur redémarre n’a aucune mémoire de l’activité de connexion précédentes). Le diagramme suivant part du principe que l’API de transport est informé de la perte de la connexion immédiatement, par conséquent, le `ConnectionSlow` événement n’est pas déclenché.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Reconnexion et défaillance du serveur](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="0cbcd-248">Si un serveur n’est pas disponible dans le délai de déconnexion, la connexion SignalR se termine.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="0cbcd-249">Dans ce scénario, le `Closed` événement (`disconnected` dans les clients JavaScript) est déclenché sur le client mais `OnDisconnected` n’est jamais appelée sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="0cbcd-250">Le diagramme suivant part du principe que le transport API ne devient-elle pas conscient de la connexion est perdue, donc il est détecté par la fonctionnalité de keepalive SignalR et `ConnectionSlow` événement est déclenché.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Délai d’expiration et de défaillance du serveur](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="0cbcd-252">Paramètres de délai d’expiration et keepalive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="0cbcd-253">La valeur par défaut `ConnectionTimeout`, `DisconnectTimeout`, et `KeepAlive` les valeurs appropriées pour la plupart des scénarios, mais peut être modifiées si votre environnement comporte des besoins particuliers.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="0cbcd-254">Par exemple, si votre environnement réseau ferme les connexions sont inactives pendant 5 secondes, vous devrez peut-être diminuer la valeur de keepalive.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="0cbcd-255">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0cbcd-255">ConnectionTimeout</span></span>

<span data-ttu-id="0cbcd-256">Ce paramètre représente la quantité de délai de maintien d’une connexion de transport ouvert et attend une réponse avant de fermer et ouvrir une nouvelle connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="0cbcd-257">La valeur par défaut est de 110 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="0cbcd-258">Ce paramètre s’applique uniquement lorsque les fonctionnalités de keepalive sont désactivée, auquel s’applique normalement qu’à long transport d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="0cbcd-259">Le diagramme suivant illustre l’effet de ce paramètre sur une longue durée d’interrogation de connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Durée pendant laquelle la connexion de transport d’interrogation](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="0cbcd-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="0cbcd-261">DisconnectTimeout</span></span>

<span data-ttu-id="0cbcd-262">Ce paramètre représente la quantité de temps d’attente après une connexion de transport est perdue avant de déclencher le `Disconnected` événement.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="0cbcd-263">La valeur par défaut est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-263">The default value is 30 seconds.</span></span> <span data-ttu-id="0cbcd-264">Lorsque vous définissez `DisconnectTimeout`, `KeepAlive` est automatiquement défini sur 1/3 de la `DisconnectTimeout` valeur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="0cbcd-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-265">KeepAlive</span></span>

<span data-ttu-id="0cbcd-266">Ce paramètre représente le délai d’attente avant l’envoi d’un paquet persistant sur une connexion inactive.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="0cbcd-267">La valeur par défaut est 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-267">The default value is 10 seconds.</span></span> <span data-ttu-id="0cbcd-268">Cette valeur ne doit pas être plus de 1/3 de la `DisconnectTimeout` valeur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="0cbcd-269">Si vous souhaitez définir les deux `DisconnectTimeout` et `KeepAlive`, affectez la valeur `KeepAlive` après `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="0cbcd-270">Sinon, votre `KeepAlive` paramètre sera remplacée lorsque `DisconnectTimeout` définit automatiquement `KeepAlive` à 1/3 de la valeur de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="0cbcd-271">Si vous souhaitez désactiver la fonctionnalité de keepalive, définissez `KeepAlive` avec la valeur null.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="0cbcd-272">Fonctionnalités de KeepAlive sont automatiquement désactivée pour le long d’interrogation de transport.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="0cbcd-273">Comment modifier les paramètres de délai d’expiration et keepalive</span><span class="sxs-lookup"><span data-stu-id="0cbcd-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="0cbcd-274">Pour modifier les valeurs par défaut pour ces paramètres, définissez-les `Application_Start` dans votre *Global.asax* de fichiers, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="0cbcd-275">Les valeurs indiquées dans l’exemple de code sont le mêmes que les valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="0cbcd-276">Comment informer l’utilisateur de déconnexions</span><span class="sxs-lookup"><span data-stu-id="0cbcd-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="0cbcd-277">Dans certaines applications, vous souhaiterez afficher un message à l’utilisateur lorsqu’il existe des problèmes de connectivité.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="0cbcd-278">Vous avez plusieurs options sur la manière et le moment pour ce faire.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="0cbcd-279">Les exemples de code suivants sont pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="0cbcd-280">Gérer le `connectionSlow` événement pour afficher un message dès que SignalR tient compte des problèmes de connexion, avant d’entrer dans le mode de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="0cbcd-281">Gérer le `reconnecting` événement pour afficher un message lorsque SignalR connaît une déconnexion et va passer à la reconnexion de mode.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="0cbcd-282">Gérer le `disconnected` événement pour afficher un message lorsqu’une tentative de reconnexion a expiré. Dans ce scénario, la seule façon de rétablir une connexion avec le serveur est de redémarrer la connexion de SignalR en appelant le `Start` (méthode), qui crée un nouvel ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="0cbcd-283">L’exemple de code suivant utilise un indicateur pour vous assurer que vous émettez la notification uniquement après un délai d’attente qui se reconnectent, pas après une fin normale à la connexion de SignalR provoquée en appelant le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="0cbcd-284">Comment reconnecter en continu</span><span class="sxs-lookup"><span data-stu-id="0cbcd-284">How to continuously reconnect</span></span>

<span data-ttu-id="0cbcd-285">Dans certaines applications, vous souhaiterez automatiquement de rétablir une connexion une fois qu’il a été perdu et de la tentative de reconnexion a expiré. Pour ce faire, vous pouvez appeler la `Start` méthode à partir de votre `Closed` Gestionnaire d’événements (`disconnected` Gestionnaire d’événements sur les clients JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="0cbcd-286">Vous souhaiterez peut-être attendre un certain temps avant d’appeler `Start` afin d’éviter cette opération trop fréquemment lorsque le serveur ou la connexion physique ne sont pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="0cbcd-287">L’exemple de code suivant est pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="0cbcd-288">Un problème potentiel à retenir dans les clients mobiles est que les tentatives de reconnexion continue lorsque le serveur ou la connexion physique n’est pas disponible peut entraîner une décharge la batterie inutiles.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="0cbcd-289">Comment se déconnecter d’un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="0cbcd-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="0cbcd-290">SignalR version 2 n’a pas d’un API de serveur intégré pour la déconnexion des clients.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="0cbcd-291">Il existe [plans pour ajouter cette fonctionnalité à l’avenir](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="0cbcd-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="0cbcd-292">Dans la version actuelle de SignalR, le plus simple pour vous déconnecter d’un client à partir du serveur consiste à implémenter une méthode de déconnexion sur le client et appeler cette méthode à partir du serveur.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="0cbcd-293">L’exemple de code suivant montre une méthode de déconnexion pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="0cbcd-294">Sécurité - ni cette méthode pour la déconnexion des clients ni l’API intégrée proposée répondront le scénario de piratés clients qui exécutent un code malveillant, dans la mesure où les clients Impossible de vous reconnecter ou le code piraté peut supprimer la `stopClient` méthode ou modification ce qu’il fait.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="0cbcd-295">L’emplacement approprié pour implémenter la protection par déni de service (DOS) avec état est pas dans l’infrastructure ou de la couche du serveur, mais plutôt dans infrastructure front-end.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="0cbcd-296">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="0cbcd-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="0cbcd-297">SignalR 2.1 ajoute une surcharge au serveur `OnDisconnect` événement qui indique si le client déconnecté délibérément plutôt que de délai d’expiration. Le `StopCalled` paramètre a la valeur true si le client a fermé explicitement la connexion.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="0cbcd-298">Dans JavaScript, si une erreur de serveur ont conduit le client pour vous déconnecter, les informations d’erreur recevront au client comme `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="0cbcd-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="0cbcd-299">**Code de serveur c# : `stopCalled` paramètre**</span><span class="sxs-lookup"><span data-stu-id="0cbcd-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="0cbcd-300">**Le code JavaScript client : l’accès à `lastError` dans le `disconnect` événement.**</span><span class="sxs-lookup"><span data-stu-id="0cbcd-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
