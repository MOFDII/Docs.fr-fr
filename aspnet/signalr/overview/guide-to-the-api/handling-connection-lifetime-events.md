---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: "Compréhension et gestion des événements de durée de vie de connexion SignalR | Documents Microsoft"
author: pfletcher
description: "Cet article décrit comment utiliser les événements exposés par l’API de concentrateurs."
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/10/2014
ms.topic: article
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
ms.technology: dotnet-signalr
ms.prod: .net-framework
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 2fd9cafd8d7706807998793c3c39377fe9604266
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/24/2018
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="8da02-103">Compréhension et gestion des événements de durée de vie de connexion SignalR</span><span class="sxs-lookup"><span data-stu-id="8da02-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="8da02-104">par [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="8da02-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="8da02-105">Cet article présente les événements de connexion et déconnexion reconnexion SignalR que vous pouvez gérer et les paramètres de délai d’attente et keepalive que vous pouvez configurer.</span><span class="sxs-lookup"><span data-stu-id="8da02-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="8da02-106">Cet article suppose que vous avez déjà une connaissance des événements de durée de vie SignalR et la connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="8da02-107">Pour obtenir une présentation SignalR, consultez [Introduction à SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="8da02-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="8da02-108">Pour les listes d’événements de durée de vie de connexion, consultez les ressources suivantes :</span><span class="sxs-lookup"><span data-stu-id="8da02-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="8da02-109">Comment gérer les événements de durée de vie de connexion dans la classe de concentrateur</span><span class="sxs-lookup"><span data-stu-id="8da02-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="8da02-110">Comment gérer les événements de durée de vie de connexion dans les clients JavaScript</span><span class="sxs-lookup"><span data-stu-id="8da02-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="8da02-111">Comment gérer les événements de durée de vie de connexion de clients .NET</span><span class="sxs-lookup"><span data-stu-id="8da02-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="8da02-112">Versions du logiciel utilisées dans cette rubrique</span><span class="sxs-lookup"><span data-stu-id="8da02-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="8da02-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="8da02-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="8da02-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="8da02-114">.NET 4.5</span></span>
> - <span data-ttu-id="8da02-115">SignalR version 2</span><span class="sxs-lookup"><span data-stu-id="8da02-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="8da02-116">Versions précédentes de cette rubrique</span><span class="sxs-lookup"><span data-stu-id="8da02-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="8da02-117">Pour plus d’informations sur les versions antérieures de SignalR, consultez [SignalR des Versions antérieures](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="8da02-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="8da02-118">Questions et des commentaires</span><span class="sxs-lookup"><span data-stu-id="8da02-118">Questions and comments</span></span>
> 
> <span data-ttu-id="8da02-119">Veuillez laisser des commentaires sur la façon dont vous avez aimé ce didacticiel et nous pouvons améliorer dans les commentaires en bas de la page.</span><span class="sxs-lookup"><span data-stu-id="8da02-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="8da02-120">Si vous avez des questions qui ne sont pas directement liées à ce didacticiel, vous pouvez les valider pour le [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) ou [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="8da02-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="8da02-121">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="8da02-121">Overview</span></span>

<span data-ttu-id="8da02-122">Cet article contient les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="8da02-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="8da02-123">Scénarios et la terminologie de durée de vie de connexion</span><span class="sxs-lookup"><span data-stu-id="8da02-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="8da02-124">Les connexions SignalR, les connexions de transport et les connexions physiques</span><span class="sxs-lookup"><span data-stu-id="8da02-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="8da02-125">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="8da02-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="8da02-126">Scénarios de déconnexion de client</span><span class="sxs-lookup"><span data-stu-id="8da02-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="8da02-127">Scénarios de déconnexion de serveurs</span><span class="sxs-lookup"><span data-stu-id="8da02-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="8da02-128">Paramètres de délai d’attente et de keepalive</span><span class="sxs-lookup"><span data-stu-id="8da02-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="8da02-129">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="8da02-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="8da02-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="8da02-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="8da02-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="8da02-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="8da02-132">Comment modifier les paramètres de délai d’attente et keepalive</span><span class="sxs-lookup"><span data-stu-id="8da02-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="8da02-133">Comment informer l’utilisateur de déconnexions</span><span class="sxs-lookup"><span data-stu-id="8da02-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="8da02-134">Comment reconnecter en continu</span><span class="sxs-lookup"><span data-stu-id="8da02-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="8da02-135">Comment se déconnecter d’un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="8da02-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="8da02-136">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="8da02-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="8da02-137">Des liens vers des rubriques de référence de l’API sont à la version de .NET 4.5 de l’API.</span><span class="sxs-lookup"><span data-stu-id="8da02-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="8da02-138">Si vous utilisez le .NET 4, consultez [la version de .NET 4 des rubriques API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="8da02-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="8da02-139">Scénarios et la terminologie de durée de vie de connexion</span><span class="sxs-lookup"><span data-stu-id="8da02-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="8da02-140">Le `OnReconnected` Gestionnaire d’événements dans un concentrateur SignalR peut exécuter directement après `OnConnected` mais pas après `OnDisconnected` pour un client donné.</span><span class="sxs-lookup"><span data-stu-id="8da02-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="8da02-141">Vous pouvez avoir une reconnexion sans une déconnexion parce qu’il existe plusieurs façons dans lequel le mot « connexion » est utilisé dans SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="8da02-142">Les connexions SignalR, les connexions de transport et les connexions physiques</span><span class="sxs-lookup"><span data-stu-id="8da02-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="8da02-143">Cet article fait la distinction entre *les connexions SignalR*, *connexions de transport*, et *connexions physiques*:</span><span class="sxs-lookup"><span data-stu-id="8da02-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="8da02-144">**Connexion SignalR** fait référence à une relation logique entre un client et une URL de serveur géré par l’API SignalR et identifiée par un ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="8da02-145">Les données relatives à cette relation sont maintenues par SignalR et sont utilisées pour établir une connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="8da02-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="8da02-146">Les terminaisons de relation et SignalR supprime les données lorsque le client appelle le `Stop` méthode ou le délai d’expiration est atteint pendant que SignalR tente de rétablir une connexion de transport perdues.</span><span class="sxs-lookup"><span data-stu-id="8da02-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="8da02-147">**Connexion de transport** fait référence à une relation logique entre un client et un serveur géré par un des quatre transport API : WebSocket, les événements de serveur a été envoyé, forever frame ou longues d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="8da02-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="8da02-148">SignalR utilise l’API de transport pour créer une connexion de transport, et l’API de transport dépend de l’existence d’une connexion réseau physique pour créer la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="8da02-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="8da02-149">La connexion de transport se termine lorsque SignalR y mette fin ou lorsque le transport API détecte que la connexion physique est interrompue.</span><span class="sxs-lookup"><span data-stu-id="8da02-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="8da02-150">**Connexion physique** fait référence aux liens réseau physique--fils, signaux sans fil, routeurs, etc., qui facilite la communication entre un ordinateur client et un ordinateur de serveur.</span><span class="sxs-lookup"><span data-stu-id="8da02-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="8da02-151">La connexion physique doit être présente pour pouvoir établir une connexion de transport, et une connexion de transport doit être établie afin d’établir une connexion SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="8da02-152">Toutefois, avec rupture de la connexion physique ne toujours immédiatement fin à la connexion de transport ou de la connexion SignalR, comme vous le verrez plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="8da02-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="8da02-153">Dans le diagramme suivant, la connexion SignalR est représentée par l’API de concentrateurs et de la couche de persistentconnection n’API SignalR, la connexion de transport est représentée par la couche de transport et la connexion physique est représentée par les lignes entre le serveur et les clients.</span><span class="sxs-lookup"><span data-stu-id="8da02-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagramme d’architecture SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="8da02-155">Lorsque vous appelez le `Start` méthode dans un client SignalR, vous fournissez le code client SignalR avec toutes les informations dont il a besoin pour établir une connexion physique à un serveur.</span><span class="sxs-lookup"><span data-stu-id="8da02-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="8da02-156">Le code client SignalR utilise ces informations pour effectuer une demande HTTP et d’établir une connexion physique qui utilise l’une des méthodes de transport de quatre.</span><span class="sxs-lookup"><span data-stu-id="8da02-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="8da02-157">Si l’échec de la connexion de transport ou le serveur échoue, la connexion SignalR ne disparaître immédiatement, car le client utilise toujours les informations nécessaires pour ré-établir automatiquement une nouvelle connexion de transport à la même URL SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="8da02-158">Dans ce scénario, sans intervention de l’utilisateur de l’application est impliquée, et lorsque le code client SignalR établit une nouvelle connexion de transport, il ne démarre pas une nouvelle connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="8da02-159">La continuité de la connexion SignalR est répercutée dans le fait que l’ID de connexion, qui est créé lorsque vous appelez le `Start` (méthode), ne change pas.</span><span class="sxs-lookup"><span data-stu-id="8da02-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="8da02-160">Le `OnReconnected` Gestionnaire d’événements sur le concentrateur s’exécute lorsqu’une connexion de transport est automatiquement rétablie après avoir été perdues.</span><span class="sxs-lookup"><span data-stu-id="8da02-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="8da02-161">Le `OnDisconnected` Gestionnaire d’événements s’exécute à la fin d’une connexion SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="8da02-162">Une connexion SignalR peut se terminer dans une des manières suivantes :</span><span class="sxs-lookup"><span data-stu-id="8da02-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="8da02-163">Si le client appelle le `Stop` (méthode), un message d’arrêt est envoyé au serveur et client et le serveur interrompt la connexion SignalR immédiatement.</span><span class="sxs-lookup"><span data-stu-id="8da02-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="8da02-164">Une fois la connectivité entre le client et le serveur est perdue, le client tente de se reconnecter et le serveur attend que le client à se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="8da02-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="8da02-165">Si les tentatives de reconnexion ont échoué et que le délai de déconnexion se termine, client et serveur mettre fin à la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="8da02-166">Le client cesse toute tentative de reconnexion, et le serveur supprime sa représentation sous forme de la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="8da02-167">Si le client cesse de s’exécuter sans la possibilité d’appeler le `Stop` (méthode), le serveur attend que le client se reconnecter, puis met fin à la connexion SignalR après un délai de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="8da02-168">Si le serveur s’arrête en cours d’exécution, le client tente de se reconnecter (recréer la connexion de transport), puis met fin à la connexion SignalR après un délai de déconnexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="8da02-169">Lorsque aucun problème de connexion, et l’utilisateur de l’application termine la connexion SignalR en appelant le `Stop` (méthode), la connexion SignalR et la connexion de transport commencer et se terminer en même temps.</span><span class="sxs-lookup"><span data-stu-id="8da02-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="8da02-170">Les sections suivantes décrivent plus en détail les autres scénarios.</span><span class="sxs-lookup"><span data-stu-id="8da02-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="8da02-171">Scénarios de déconnexion de transport</span><span class="sxs-lookup"><span data-stu-id="8da02-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="8da02-172">Connexions physiques peuvent être lentes ou il peut y avoir des interruptions de connectivité.</span><span class="sxs-lookup"><span data-stu-id="8da02-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="8da02-173">En fonction de facteurs tels que la longueur de l’interruption, la connexion de transport peut-être être supprimée.</span><span class="sxs-lookup"><span data-stu-id="8da02-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="8da02-174">SignalR puis tente de rétablir la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="8da02-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="8da02-175">Parfois, la connexion de transport API détecte l’interruption et supprime la connexion de transport, et SignalR constate immédiatement que la connexion est perdue.</span><span class="sxs-lookup"><span data-stu-id="8da02-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="8da02-176">Dans d’autres scénarios, la connexion de transport API ni SignalR est informé immédiatement que la connectivité a été perdue.</span><span class="sxs-lookup"><span data-stu-id="8da02-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="8da02-177">Pour tous les transports, à l’exception d’interrogation longue, le client SignalR utilise une fonction appelée *keepalive* pour vérifier une perte de connectivité utilisés par l’API de transport ne peut pas détecter.</span><span class="sxs-lookup"><span data-stu-id="8da02-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="8da02-178">Pour plus d’informations sur la durée pendant laquelle les connexions d’interrogation, consultez [les paramètres de délai d’attente et keepalive](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="8da02-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="8da02-179">Lorsqu’une connexion est inactive, le serveur envoie régulièrement un paquet persistant au client.</span><span class="sxs-lookup"><span data-stu-id="8da02-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="8da02-180">À compter de la date de que cet article est écrit, la fréquence par défaut est toutes les 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="8da02-181">En écoutant à ces paquets, les clients peuvent indiquer s’il existe un problème de connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="8da02-182">Si un paquet persistant n’est pas reçu lorsque attendu après un bref moment le client suppose qu’il existe des problèmes de connexion telles que la lenteur ou interruptions.</span><span class="sxs-lookup"><span data-stu-id="8da02-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="8da02-183">Si le keepalive n’est toujours pas reçu après une durée plus longue, le client suppose que la connexion a été supprimée et qu’il commence à essayer de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="8da02-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="8da02-184">Le diagramme suivant illustre les événements qui sont déclenchés dans un scénario classique, lorsqu’il existe des problèmes avec la connexion physique qui ne sont pas immédiatement reconnus par le transport API client et serveur.</span><span class="sxs-lookup"><span data-stu-id="8da02-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="8da02-185">Le diagramme s’applique dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="8da02-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="8da02-186">Le transport est WebSockets, forever frame ou événements de serveur a été envoyé.</span><span class="sxs-lookup"><span data-stu-id="8da02-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="8da02-187">Il existe différentes périodes d’interruption de la connexion réseau physique.</span><span class="sxs-lookup"><span data-stu-id="8da02-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="8da02-188">L’API de transport ne tient pas d’interruptions, y compris pour SignalR s’appuie sur les fonctionnalités keepalive pour détecter les.</span><span class="sxs-lookup"><span data-stu-id="8da02-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Déconnexion de transport](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="8da02-190">Si le client passe en mode de reconnexion, mais ne peut pas établir une connexion de transport dans le délai de déconnexion, le serveur met fin à la connexion de SignalR.</span><span class="sxs-lookup"><span data-stu-id="8da02-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="8da02-191">Lorsque cela se produit, le serveur s’exécute de concentrateur `OnDisconnected` méthode et les files d’attente d’un message de déconnexion à envoyer au client dans le cas où le client parvient à se connecter plus tard.</span><span class="sxs-lookup"><span data-stu-id="8da02-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="8da02-192">Si le client puis se reconnecte, il reçoit la commande de déconnexion et appelle le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8da02-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="8da02-193">Dans ce scénario, `OnReconnected` n’est pas exécuté lorsque le client se reconnecte, et `OnDisconnected` n’est pas exécuté lorsque le client appelle `Stop`.</span><span class="sxs-lookup"><span data-stu-id="8da02-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="8da02-194">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="8da02-194">The following diagram illustrates this scenario.</span></span>

![Interruptions de transport - délai d’attente du serveur](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="8da02-196">Les événements de durée de vie de connexion SignalR qui peuvent être déclenchés sur le client sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="8da02-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="8da02-197">`ConnectionSlow`événements du client.</span><span class="sxs-lookup"><span data-stu-id="8da02-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="8da02-198">Déclenché lorsqu’une partie prédéfinie de la période de délai d’attente de keepalive est dépassé depuis le dernier message ou keepalive ping a été reçu.</span><span class="sxs-lookup"><span data-stu-id="8da02-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="8da02-199">Le délai d’avertissement par défaut keepalive est 2/3 du délai de keepalive.</span><span class="sxs-lookup"><span data-stu-id="8da02-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="8da02-200">Le délai d’attente keepalive étant 20 secondes, l’avertissement se produit au niveau d’environ 13 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="8da02-201">Par défaut, le serveur envoie les pings keepalive toutes les 10 secondes, et le client recherche les pings keepalive sur toutes les 2 secondes (un tiers de la différence entre la valeur de délai d’attente de keepalive et la valeur d’avertissement de délai d’attente keepalive).</span><span class="sxs-lookup"><span data-stu-id="8da02-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="8da02-202">Si le transport API reconnaît une déconnexion, SignalR peut être informé de la déconnexion avant que le délai d’avertissement keepalive passe.</span><span class="sxs-lookup"><span data-stu-id="8da02-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="8da02-203">Dans ce cas, le `ConnectionSlow` événement n’est pas déclenché, et SignalR va passer directement à la `Reconnecting` événement.</span><span class="sxs-lookup"><span data-stu-id="8da02-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="8da02-204">`Reconnecting`événements du client.</span><span class="sxs-lookup"><span data-stu-id="8da02-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="8da02-205">Déclenché lorsque l’API de transport détecte que la connexion est perdue, ou (b) le délai d’attente keepalive est dépassé depuis le dernier message ou keepalive ping a été reçu.</span><span class="sxs-lookup"><span data-stu-id="8da02-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="8da02-206">Le code client SignalR commence tente de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="8da02-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="8da02-207">Vous pouvez gérer cet événement si vous souhaitez que votre application pour intervenir lors d’une connexion de transport est perdue.</span><span class="sxs-lookup"><span data-stu-id="8da02-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="8da02-208">Le délai de conservation par défaut est actuellement de 20 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="8da02-209">Si votre code client tente d’appeler une méthode de concentrateur pendant la reconnexion mode SignalR, SignalR va tenter d’envoyer la commande.</span><span class="sxs-lookup"><span data-stu-id="8da02-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="8da02-210">La plupart du temps, telles que les tentatives échouent, mais dans certains cas, il peuvent réussir.</span><span class="sxs-lookup"><span data-stu-id="8da02-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="8da02-211">Pour l’envoyées au serveur, forever frame et événements durée pendant laquelle les transports d’interrogation, SignalR utilise deux canaux de communication, le client utilise pour envoyer des messages et l’autre qu’elle utilise pour recevoir des messages.</span><span class="sxs-lookup"><span data-stu-id="8da02-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="8da02-212">Le canal utilisé pour la réception est celle qui est ouverte en permanence et qui est celle qui est fermé lorsque la connexion physique est interrompue.</span><span class="sxs-lookup"><span data-stu-id="8da02-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="8da02-213">Le canal utilisé pour l’envoi reste disponible, si la connectivité physique est restaurée, un appel de méthode à partir du client au serveur peut donc être réussi avant que le canal de réception est rétabli.</span><span class="sxs-lookup"><span data-stu-id="8da02-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="8da02-214">La valeur de retour n’est pas reçue jusqu'à ce que SignalR ouvre le canal utilisé pour la réception.</span><span class="sxs-lookup"><span data-stu-id="8da02-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="8da02-215">`Reconnected`événements du client.</span><span class="sxs-lookup"><span data-stu-id="8da02-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="8da02-216">Déclenché lorsque la connexion de transport est rétablie.</span><span class="sxs-lookup"><span data-stu-id="8da02-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="8da02-217">Le `OnReconnected` s’exécute le Gestionnaire d’événements dans le concentrateur.</span><span class="sxs-lookup"><span data-stu-id="8da02-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="8da02-218">`Closed`événements du client (`disconnected` événement en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="8da02-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="8da02-219">Déclenché lorsque le délai de déconnexion arrive à expiration alors que le code client SignalR tente de se reconnecter après la perte de la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="8da02-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="8da02-220">La valeur par défaut déconnecter délai d’expiration est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="8da02-221">(Cet événement est également déclenché lorsque la connexion se termine parce que le `Stop` méthode est appelée.)</span><span class="sxs-lookup"><span data-stu-id="8da02-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="8da02-222">Les interruptions de connexion de transport qui ne sont pas détectées par l’API de transport et de ne pas retarder la réception du ping keepalive à partir du serveur pendant plus longtemps que le délai d’avertissement keepalive peut ne pas provoquent toute connexion déclenchement des événements de durée de vie.</span><span class="sxs-lookup"><span data-stu-id="8da02-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="8da02-223">Certains environnements réseau délibérément fermer les connexions inactives, et une autre fonction, des paquets de keepalive est pour résoudre ce problème en vous permettant de que ces réseaux savent qu’une connexion SignalR est en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="8da02-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="8da02-224">Dans les cas extrêmes la fréquence par défaut de keepalive pings peut-être pas suffisante pour empêcher les connexions fermées.</span><span class="sxs-lookup"><span data-stu-id="8da02-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="8da02-225">Dans ce cas, vous pouvez configurer les pings keepalive à envoyer plus souvent.</span><span class="sxs-lookup"><span data-stu-id="8da02-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="8da02-226">Pour plus d’informations, consultez [les paramètres de délai d’attente et keepalive](#timeoutkeepalive) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="8da02-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="8da02-227">**Important**: la séquence d’événements décrites ici n’est pas garantie.</span><span class="sxs-lookup"><span data-stu-id="8da02-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="8da02-228">SignalR effectue chaque tentative pour déclencher des événements de durée de vie de connexion de manière prévisible en fonction de ce schéma, mais il existe de nombreuses variations d’événements réseau et dans lequel des infrastructures de communication sous-jacent comme transport API les gérer de nombreuses façons.</span><span class="sxs-lookup"><span data-stu-id="8da02-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="8da02-229">Par exemple, le `Reconnected` événement ne peut pas être déclenché lorsque le client se reconnecte, ou le `OnConnected` gestionnaire sur le serveur peut s’exécuter lors de la tentative pour établir une connexion a échoué.</span><span class="sxs-lookup"><span data-stu-id="8da02-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="8da02-230">Cette rubrique décrit uniquement les effets qui sont normalement produits par certains circonstances normales.</span><span class="sxs-lookup"><span data-stu-id="8da02-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="8da02-231">Scénarios de déconnexion de client</span><span class="sxs-lookup"><span data-stu-id="8da02-231">Client disconnection scenarios</span></span>

<span data-ttu-id="8da02-232">Dans un navigateur client, le code client SignalR qui conserve une connexion SignalR s’exécute dans le contexte JavaScript d’une page web.</span><span class="sxs-lookup"><span data-stu-id="8da02-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="8da02-233">Qui a pourquoi la connexion SignalR possède à la fin lorsque vous accédez à partir d’une page à un autre et ce de pourquoi vous avez plusieurs connexions avec plusieurs ID de connexion si vous vous connectez à partir de plusieurs onglets ou fenêtres du navigateur.</span><span class="sxs-lookup"><span data-stu-id="8da02-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="8da02-234">Lorsque l’utilisateur ferme une fenêtre de navigateur ou un onglet, ou navigue vers une nouvelle page ou actualise la page, la connexion de SignalR se termine immédiatement, car le code client SignalR gère cet événement de navigateur pour vous et appelle le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8da02-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="8da02-235">Dans ces scénarios, ou dans n’importe quelle plate-forme client lorsque votre application appelle la `Stop` (méthode), la `OnDisconnected` Gestionnaire d’événements s’exécute immédiatement sur le serveur et le client déclenche le `Closed` événement (l’événement nommé `disconnected` dans JavaScript).</span><span class="sxs-lookup"><span data-stu-id="8da02-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="8da02-236">Si une application cliente ou l’ordinateur sur lequel il est exécuté sur tombe en panne ou mis en veille (par exemple, lorsque l’utilisateur ferme l’ordinateur portable), le serveur n’est pas informé de ce qui est arrivé.</span><span class="sxs-lookup"><span data-stu-id="8da02-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="8da02-237">Comme le serveur sait, la perte du client peut être en raison d’une interruption de connexion et le client peut être tente de se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="8da02-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="8da02-238">Par conséquent, dans ces scénarios, le serveur attend avant de donner au client une chance de vous reconnecter, et `OnDisconnected` ne s’exécute pas jusqu'à ce que le délai de déconnexion expire (environ 30 secondes par défaut).</span><span class="sxs-lookup"><span data-stu-id="8da02-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="8da02-239">Le diagramme suivant illustre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="8da02-239">The following diagram illustrates this scenario.</span></span>

![Échec de l’ordinateur client](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="8da02-241">Scénarios de déconnexion de serveurs</span><span class="sxs-lookup"><span data-stu-id="8da02-241">Server disconnection scenarios</span></span>

<span data-ttu-id="8da02-242">Lorsqu’un serveur est mis hors connexion--il redémarre, échoue, le domaine d’application recycle, etc.--le résultat peut être semblable à une perte de connexion ou l’API de transport et SignalR peuvent savoir immédiatement que le serveur a disparu, SignalR pourrait commencer tente de se reconnecter sans déclencher la `ConnectionSlow` événement.</span><span class="sxs-lookup"><span data-stu-id="8da02-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="8da02-243">Si le client passe en mode de reconnexion et si le serveur récupère ou de redémarrage ou un nouveau serveur est mis en ligne avant l’expiration de la période de délai d’attente de déconnexion, le client se reconnectera sur le serveur restauré ou nouvel.</span><span class="sxs-lookup"><span data-stu-id="8da02-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="8da02-244">Dans ce cas, la connexion SignalR continue sur le client et le `Reconnected` événement est déclenché.</span><span class="sxs-lookup"><span data-stu-id="8da02-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="8da02-245">Sur le premier serveur, `OnDisconnected` n’est jamais exécutée et sur le nouveau serveur, `OnReconnected` est exécutée bien que `OnConnected` a été jamais exécutée pour le client sur ce serveur avant.</span><span class="sxs-lookup"><span data-stu-id="8da02-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="8da02-246">(L’effet est le même si le client se reconnecte au même serveur après un recyclage de domaine d’application ou de redémarrage, car lorsque le serveur redémarre n’a aucune mémoire de l’activité de connexion préalable). Le diagramme suivant part du principe que l’API de transport est informé de la perte de connexion immédiatement, donc la `ConnectionSlow` événement n’est pas déclenché.</span><span class="sxs-lookup"><span data-stu-id="8da02-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Échec du serveur et reconnexion](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="8da02-248">Si un serveur n’est pas disponible dans le délai de déconnexion, la connexion SignalR se termine.</span><span class="sxs-lookup"><span data-stu-id="8da02-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="8da02-249">Dans ce scénario, le `Closed` événement (`disconnected` dans les clients JavaScript) est déclenché sur le client mais `OnDisconnected` n’est jamais appelée sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="8da02-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="8da02-250">Le diagramme suivant part du principe que l’API de transport ne devient-elle pas informé de la perte de connexion, afin qu’il est détecté par la fonctionnalité de keepalive SignalR et `ConnectionSlow` événement est déclenché.</span><span class="sxs-lookup"><span data-stu-id="8da02-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Délai d’attente et de défaillance du serveur](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="8da02-252">Paramètres de délai d’attente et de keepalive</span><span class="sxs-lookup"><span data-stu-id="8da02-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="8da02-253">La valeur par défaut `ConnectionTimeout`, `DisconnectTimeout`, et `KeepAlive` les valeurs appropriées pour la plupart des scénarios mais peut être modifiées si votre environnement a des besoins particuliers.</span><span class="sxs-lookup"><span data-stu-id="8da02-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="8da02-254">Par exemple, si votre environnement réseau ferme les connexions sont inactives pendant 5 secondes, vous devrez peut-être diminuer la valeur keepalive.</span><span class="sxs-lookup"><span data-stu-id="8da02-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="8da02-255">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="8da02-255">ConnectionTimeout</span></span>

<span data-ttu-id="8da02-256">Ce paramètre représente la durée du délai de maintien d’une connexion de transport ouverts et attend une réponse avant de fermer et ouvrir une nouvelle connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="8da02-257">La valeur par défaut est de 110 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="8da02-258">Ce paramètre s’applique uniquement lorsque les fonctionnalités de keepalive sont désactivée, qui s’applique uniquement à la longue généralement transport d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="8da02-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="8da02-259">Le diagramme suivant illustre l’effet de ce paramètre sur une longue durée d’interrogation de la connexion de transport.</span><span class="sxs-lookup"><span data-stu-id="8da02-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Durée pendant laquelle la connexion de transport d’interrogation](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="8da02-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="8da02-261">DisconnectTimeout</span></span>

<span data-ttu-id="8da02-262">Ce paramètre représente la quantité de temps d’attente après la perte de la connexion de transport avant de déclencher la `Disconnected` événement.</span><span class="sxs-lookup"><span data-stu-id="8da02-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="8da02-263">La valeur par défaut est de 30 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-263">The default value is 30 seconds.</span></span> <span data-ttu-id="8da02-264">Lorsque vous définissez `DisconnectTimeout`, `KeepAlive` est automatiquement défini sur 1/3 de la `DisconnectTimeout` valeur.</span><span class="sxs-lookup"><span data-stu-id="8da02-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="8da02-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="8da02-265">KeepAlive</span></span>

<span data-ttu-id="8da02-266">Ce paramètre représente la quantité de temps d’attente avant l’envoi d’un paquet persistant sur une connexion inactive.</span><span class="sxs-lookup"><span data-stu-id="8da02-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="8da02-267">La valeur par défaut est 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="8da02-267">The default value is 10 seconds.</span></span> <span data-ttu-id="8da02-268">Cette valeur ne doit pas être supérieure à 1/3 de la `DisconnectTimeout` valeur.</span><span class="sxs-lookup"><span data-stu-id="8da02-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="8da02-269">Si vous souhaitez définir les deux `DisconnectTimeout` et `KeepAlive`, définissez `KeepAlive` après `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="8da02-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="8da02-270">Dans le cas contraire votre `KeepAlive` paramètre sera remplacée lorsque `DisconnectTimeout` définit automatiquement `KeepAlive` à 1/3 de la valeur de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="8da02-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="8da02-271">Si vous souhaitez désactiver la fonctionnalité de keepalive, définissez `KeepAlive` avec la valeur null.</span><span class="sxs-lookup"><span data-stu-id="8da02-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="8da02-272">Fonctionnalités de KeepAlive sont automatiquement désactivée pour la longue transport d’interrogation.</span><span class="sxs-lookup"><span data-stu-id="8da02-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="8da02-273">Comment modifier les paramètres de délai d’attente et keepalive</span><span class="sxs-lookup"><span data-stu-id="8da02-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="8da02-274">Pour modifier les valeurs par défaut pour ces paramètres, définissez-les dans `Application_Start` dans votre *Global.asax* de fichiers, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="8da02-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="8da02-275">Les valeurs indiquées dans l’exemple de code sont les mêmes que les valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="8da02-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="8da02-276">Comment informer l’utilisateur de déconnexions</span><span class="sxs-lookup"><span data-stu-id="8da02-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="8da02-277">Dans certaines applications, vous souhaiterez afficher un message à l’utilisateur lorsqu’il existe des problèmes de connectivité.</span><span class="sxs-lookup"><span data-stu-id="8da02-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="8da02-278">Vous avez plusieurs options pour la procédure et quand cela.</span><span class="sxs-lookup"><span data-stu-id="8da02-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="8da02-279">Les exemples de code suivants sont pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="8da02-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="8da02-280">Gérer les `connectionSlow` événements pour afficher un message dès que SignalR est informé des problèmes de connexion, avant d’entrer en mode de reconnexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="8da02-281">Gérer les `reconnecting` événements pour afficher un message lorsque SignalR connaît une déconnexion et va passer à la reconnexion de mode.</span><span class="sxs-lookup"><span data-stu-id="8da02-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="8da02-282">Gérer les `disconnected` événements pour afficher un message lorsqu’une tentative de reconnexion a expiré. Dans ce scénario, la seule façon de rétablir une connexion avec le serveur est de redémarrer la connexion SignalR en appelant le `Start` (méthode), qui crée un nouvel ID de connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="8da02-283">L’exemple de code suivant utilise un indicateur pour vous assurer que vous émettez la notification uniquement après un délai d’attente de reconnexion, pas après une fin normale à la connexion SignalR provoquée en appelant le `Stop` (méthode).</span><span class="sxs-lookup"><span data-stu-id="8da02-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="8da02-284">Comment reconnecter en continu</span><span class="sxs-lookup"><span data-stu-id="8da02-284">How to continuously reconnect</span></span>

<span data-ttu-id="8da02-285">Dans certaines applications, vous souhaiterez automatiquement de rétablir une connexion une fois qu’il a été perdu et la tentative de reconnexion a expiré. Pour ce faire, vous pouvez appeler la `Start` méthode à partir de votre `Closed` Gestionnaire d’événements (`disconnected` Gestionnaire d’événements sur les clients JavaScript).</span><span class="sxs-lookup"><span data-stu-id="8da02-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="8da02-286">Vous souhaiterez peut-être attendre une période de temps avant d’appeler `Start` afin d’éviter cela trop fréquemment lorsque le serveur ou la connexion physique ne sont pas disponibles.</span><span class="sxs-lookup"><span data-stu-id="8da02-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="8da02-287">L’exemple de code suivant est pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="8da02-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="8da02-288">Un problème potentiel de connaître les clients mobiles est que les tentatives de reconnexion en continu lorsque le serveur ou la connexion physique n’est pas disponible peut entraîner la décharge inutiles de la batterie.</span><span class="sxs-lookup"><span data-stu-id="8da02-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="8da02-289">Comment se déconnecter d’un client dans le code serveur</span><span class="sxs-lookup"><span data-stu-id="8da02-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="8da02-290">SignalR version 2 n’a pas d’un API de serveur intégré pour déconnecter les clients.</span><span class="sxs-lookup"><span data-stu-id="8da02-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="8da02-291">Il n’y [des plans pour l’ajout de cette fonctionnalité dans le futur](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="8da02-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="8da02-292">Dans la version actuelle de SignalR, la plus simple pour déconnecter un client à partir du serveur consiste à implémenter une méthode de déconnexion sur le client et appelez cette méthode à partir du serveur.</span><span class="sxs-lookup"><span data-stu-id="8da02-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="8da02-293">L’exemple de code suivant montre une méthode de déconnexion pour un client JavaScript à l’aide du proxy généré.</span><span class="sxs-lookup"><span data-stu-id="8da02-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="8da02-294">Sécurité - cette méthode pour déconnecter les clients ni l’API intégrée proposée traitant le scénario de piraté clients qui exécutent un code malveillant, étant donné que les clients peuvent se reconnecter ou le code piraté risque de supprimer la `stopClient` méthode ou modification ce qu’il fait.</span><span class="sxs-lookup"><span data-stu-id="8da02-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="8da02-295">L’emplacement approprié pour implémenter la protection déni de service (DOS) avec état est pas dans l’infrastructure ou de la couche du serveur, mais dans infrastructure front-end.</span><span class="sxs-lookup"><span data-stu-id="8da02-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="8da02-296">Détection de la raison d’une déconnexion</span><span class="sxs-lookup"><span data-stu-id="8da02-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="8da02-297">SignalR 2.1 ajoute une surcharge sur le serveur `OnDisconnect` événement qui indique si le client déconnecté délibérément plutôt que d’arriver à expiration. Le `StopCalled` paramètre a la valeur true si le client ferme explicitement la connexion.</span><span class="sxs-lookup"><span data-stu-id="8da02-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="8da02-298">Dans JavaScript, si une erreur de serveur conduit le client pour vous déconnecter, les informations d’erreur seront passées au client en tant que `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="8da02-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="8da02-299">**Code de serveur c# : `stopCalled` paramètre**</span><span class="sxs-lookup"><span data-stu-id="8da02-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="8da02-300">**Le code JavaScript client : l’accès à `lastError` dans le `disconnect` événement.**</span><span class="sxs-lookup"><span data-stu-id="8da02-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
