---
title: "Dérivation de sous-clés et de chiffrement authentifié"
author: rick-anderson
description: "Ce document explique les détails d’implémentation de la protection des données ASP.NET Core dérivation des sous-clés et authentifié de chiffrement."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 7db0bb7cd641512e7e5850e1765ad5b3e54e3aca
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/24/2018
---
# <a name="subkey-derivation-and-authenticated-encryption"></a><span data-ttu-id="82116-103">Dérivation de sous-clés et de chiffrement authentifié</span><span class="sxs-lookup"><span data-stu-id="82116-103">Subkey Derivation and Authenticated Encryption</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="82116-104">La plupart des clés dans l’anneau de clé contiendra une certaine forme d’entropie et contient des informations algorithmiques indiquant « le chiffrement en mode CBC + validation de HMAC » ou « chiffrement de GCM + validation ».</span><span class="sxs-lookup"><span data-stu-id="82116-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="82116-105">Dans ce cas, nous nous référons à l’entropie incorporé en tant que le support de gestion (ou KM) pour cette clé, et que nous effectuons une fonction de dérivation de clé pour dériver les clés qui seront utilisés pour les opérations de chiffrement réelles.</span><span class="sxs-lookup"><span data-stu-id="82116-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="82116-106">Les clés sont abstraites, et une implémentation personnalisée ne peut-être pas se comporter comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="82116-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="82116-107">Si la clé fournit sa propre implémentation de `IAuthenticatedEncryptor` au lieu d’utiliser une des usines intégrées, le mécanisme décrit dans cette section ne s’applique plus.</span><span class="sxs-lookup"><span data-stu-id="82116-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="82116-108">Données authentifiées supplémentaires et la dérivation de la sous-clé</span><span class="sxs-lookup"><span data-stu-id="82116-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="82116-109">Le `IAuthenticatedEncryptor` interface sert d’interface de base pour toutes les opérations de chiffrement authentifié.</span><span class="sxs-lookup"><span data-stu-id="82116-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="82116-110">Son `Encrypt` méthode prend deux mémoires tampons : texte en clair et additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="82116-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="82116-111">Le flux de contenu de texte en clair sans modification de l’appel à `IDataProtector.Protect`, mais le AAD est généré par le système et se compose de trois composants :</span><span class="sxs-lookup"><span data-stu-id="82116-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="82116-112">L’en-tête magic 32 bits 09 F0 C9 F0 qui identifie cette version du système de protection des données.</span><span class="sxs-lookup"><span data-stu-id="82116-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="82116-113">L’id de clé 128 bits.</span><span class="sxs-lookup"><span data-stu-id="82116-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="82116-114">Une chaîne de longueur variable formée à partir de la chaîne de l’objectif qui a créé le `IDataProtector` qui effectue cette opération.</span><span class="sxs-lookup"><span data-stu-id="82116-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="82116-115">Étant donné que le AAD est unique pour le tuple de tous les trois composants, nous pouvons l’utiliser pour dériver les nouvelles clés à partir du Gestionnaire de clés au lieu d’utiliser KM lui-même dans tous nos opérations cryptographiques.</span><span class="sxs-lookup"><span data-stu-id="82116-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="82116-116">Pour chaque appel à `IAuthenticatedEncryptor.Encrypt`, le processus de dérivation de clé suivant a lieu :</span><span class="sxs-lookup"><span data-stu-id="82116-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="82116-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="82116-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="82116-118">Ici, nous appelons NIST SP800-108 KDF en Mode de compteur (consultez [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), s 5.1) avec les paramètres suivants :</span><span class="sxs-lookup"><span data-stu-id="82116-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="82116-119">Clé de dérivation de clé (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="82116-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="82116-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="82116-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="82116-121">étiquette = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="82116-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="82116-122">contexte = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="82116-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="82116-123">L’en-tête de contexte est de longueur variable et sert essentiellement une empreinte numérique des algorithmes pour lequel nous allons dérivation K_E et K_H.</span><span class="sxs-lookup"><span data-stu-id="82116-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="82116-124">Le modificateur de clé est une chaîne de 128 bits générée de façon aléatoire pour chaque appel à `Encrypt` et sert à garantir avec surcharger la probabilité que KE et KH sont uniques pour cette opération de chiffrement d’authentification spécifique, même si toutes les autres entrées au KDF sont constante.</span><span class="sxs-lookup"><span data-stu-id="82116-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="82116-125">Pour le chiffrement en mode CBC + des opérations de validation HMAC, | K_E | est la longueur de la clé de chiffrement symétrique, et | K_H | est la taille du résumé de la routine HMAC.</span><span class="sxs-lookup"><span data-stu-id="82116-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="82116-126">Pour le chiffrement de GCM + des opérations de validation, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="82116-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="82116-127">Le chiffrement en mode CBC + validation de HMAC</span><span class="sxs-lookup"><span data-stu-id="82116-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="82116-128">Une fois que K_E est généré par le biais du mécanisme ci-dessus, nous générer un vecteur d’initialisation aléatoire et exécuter l’algorithme de chiffrement symétrique pour chiffrer le texte en clair.</span><span class="sxs-lookup"><span data-stu-id="82116-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="82116-129">Le vecteur d’initialisation et le texte chiffré sont ensuite exécutées via la routine HMAC initialisée avec la clé K_H pour produire le Mac.</span><span class="sxs-lookup"><span data-stu-id="82116-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="82116-130">Ce processus et la valeur de retour est représenté sous forme graphique ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="82116-130">This process and the return value is represented graphically below.</span></span>

![Retour et les processus en mode CBC](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="82116-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span><span class="sxs-lookup"><span data-stu-id="82116-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="82116-133">Le `IDataProtector.Protect` implémentation sera [ajouter l’en-tête magic et l’id de clé](authenticated-encryption-details.md) de sortie avant de le renvoyer à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="82116-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](authenticated-encryption-details.md) to output before returning it to the caller.</span></span> <span data-ttu-id="82116-134">Étant donné que l’en-tête magic et l’id de clé sont implicitement dans le cadre du [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), et étant donné que le modificateur de clé est acheminé comme entrée au KDF, cela signifie que chaque octet de la charge utile de retourné finale est authentifié par le Mac.</span><span class="sxs-lookup"><span data-stu-id="82116-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="82116-135">Le chiffrement du Mode de compteur/GALOIS + validation</span><span class="sxs-lookup"><span data-stu-id="82116-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="82116-136">Une fois que K_E est généré par le biais du mécanisme ci-dessus, nous générer une valeur à usage unique à 96 bits aléatoire et exécuter l’algorithme de chiffrement symétrique pour chiffrer le texte en clair et de produire la balise d’authentification de 128 bits.</span><span class="sxs-lookup"><span data-stu-id="82116-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Retour et les processus en mode GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="82116-138">*sortie : = keyModifier || valeur à usage unique || E_gcm (K_E, valeur à usage unique, de données) || authTag*</span><span class="sxs-lookup"><span data-stu-id="82116-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="82116-139">Même si GCM prend nativement en charge le concept d’AAD, nous sommes toujours à l’alimentation AAD uniquement KDF d’origine, pour passer une chaîne vide en GCM pour son paramètre AAD.</span><span class="sxs-lookup"><span data-stu-id="82116-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="82116-140">La raison à cela est double.</span><span class="sxs-lookup"><span data-stu-id="82116-140">The reason for this is two-fold.</span></span> <span data-ttu-id="82116-141">Tout d’abord, [pour prendre en charge agilité](context-headers.md#data-protection-implementation-context-headers) que nous ne souhaitons utiliser K_M directement en tant que la clé de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="82116-141">First, [to support agility](context-headers.md#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="82116-142">En outre, GCM impose des exigences très strictes unicité sur ses entrées.</span><span class="sxs-lookup"><span data-stu-id="82116-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="82116-143">La probabilité que la routine de chiffrement GCM n’est jamais appelée sur deux ou plus distincte des jeux de données d’entrée avec le même (clé, valeur à usage unique) paire ne doit pas dépasser 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="82116-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="82116-144">Si nous corriger K_E nous ne pouvons pas effectuer plus de 2 ^ 32 opérations de chiffrement avant d’exécuter que nous afoul of le 2 ^ -32 limiter.</span><span class="sxs-lookup"><span data-stu-id="82116-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="82116-145">Cela peut sembler un très grand nombre d’opérations, mais un serveur web de trafic élevé peut subir de 4 milliards de demandes en jours simples, dans la durée de vie normale pour ces clés.</span><span class="sxs-lookup"><span data-stu-id="82116-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="82116-146">Pour rester conformes de 2 ^ limite de la probabilité de-32, que nous continuons à utiliser un modificateur de clé de 128 bits et les 96 bits valeur à usage unique, qui étend radicalement le nombre d’opérations utilisable pour n’importe quel K_M donné.</span><span class="sxs-lookup"><span data-stu-id="82116-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="82116-147">Par souci de simplicité de conception, nous partageons le chemin d’accès du code KDF entre les opérations CBC et GCM et AAD est déjà pris en compte dans le KDF il est inutile de transférer à la routine GCM.</span><span class="sxs-lookup"><span data-stu-id="82116-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
