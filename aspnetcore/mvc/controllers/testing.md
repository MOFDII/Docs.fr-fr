---
title: "Pour tester la logique de contrôleur dans ASP.NET Core"
author: ardalis
description: "En savoir plus sur la logique du contrôleur de test dans ASP.NET Core avec Moq et xUnit."
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.technology: aspnet
ms.prod: asp.net-core
uid: mvc/controllers/testing
ms.openlocfilehash: f27e7ec43cd17e249dd646a7dfbce5df69d59664
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/24/2018
---
# <a name="testing-controller-logic-in-aspnet-core"></a><span data-ttu-id="dee0e-103">Pour tester la logique de contrôleur dans ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="dee0e-103">Testing controller logic in ASP.NET Core</span></span>

<span data-ttu-id="dee0e-104">Par [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="dee0e-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="dee0e-105">Contrôleurs dans les applications ASP.NET MVC doivent être petit et se concentrent sur les problèmes d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="dee0e-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="dee0e-106">Contrôleurs de grande taille qui traitent des problèmes d’interface utilisateur sont plus difficiles à tester et mettre à jour.</span><span class="sxs-lookup"><span data-stu-id="dee0e-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="dee0e-107">Afficher ou télécharger l’exemple à partir de GitHub</span><span class="sxs-lookup"><span data-stu-id="dee0e-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="dee0e-108">Contrôleurs de tests</span><span class="sxs-lookup"><span data-stu-id="dee0e-108">Testing controllers</span></span>

<span data-ttu-id="dee0e-109">Contrôleurs sont une partie centrale d’une application ASP.NET MVC de base.</span><span class="sxs-lookup"><span data-stu-id="dee0e-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="dee0e-110">Par conséquent, vous devez avoir confiance qu’ils se comportent comme prévu pour votre application.</span><span class="sxs-lookup"><span data-stu-id="dee0e-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="dee0e-111">Tests automatisés peuvent vous fournir cette confiance et peuvent détecter les erreurs avant qu’ils atteignent la production.</span><span class="sxs-lookup"><span data-stu-id="dee0e-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="dee0e-112">Il est important d’éviter de placer des responsabilités inutiles dans vos contrôleurs et vérifiez votre focus tests uniquement sur les responsabilités de contrôleur.</span><span class="sxs-lookup"><span data-stu-id="dee0e-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="dee0e-113">Logique de contrôleur doit être minime et n’est ne pas être axée sur les problèmes métier logique ou d’infrastructure (par exemple, accès aux données).</span><span class="sxs-lookup"><span data-stu-id="dee0e-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="dee0e-114">Tester la logique du contrôleur, pas l’infrastructure.</span><span class="sxs-lookup"><span data-stu-id="dee0e-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="dee0e-115">Test comment le contrôleur *se comporte* basé sur les entrées valides ou non valides.</span><span class="sxs-lookup"><span data-stu-id="dee0e-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="dee0e-116">En fonction du résultat de l’opération métier qu'il effectue des réponses du contrôleur de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="dee0e-117">Responsabilités du contrôleur classique :</span><span class="sxs-lookup"><span data-stu-id="dee0e-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="dee0e-118">Vérifiez `ModelState.IsValid`.</span><span class="sxs-lookup"><span data-stu-id="dee0e-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="dee0e-119">Retourne une réponse d’erreur si `ModelState` n’est pas valide.</span><span class="sxs-lookup"><span data-stu-id="dee0e-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="dee0e-120">Récupérer une entité commerciale de persistance.</span><span class="sxs-lookup"><span data-stu-id="dee0e-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="dee0e-121">Effectuer une action sur l’entité métier.</span><span class="sxs-lookup"><span data-stu-id="dee0e-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="dee0e-122">Enregistrer l’entité métier à la persistance.</span><span class="sxs-lookup"><span data-stu-id="dee0e-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="dee0e-123">Renvoyer un approprié `IActionResult`.</span><span class="sxs-lookup"><span data-stu-id="dee0e-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="dee0e-124">Test unitaire</span><span class="sxs-lookup"><span data-stu-id="dee0e-124">Unit testing</span></span>

<span data-ttu-id="dee0e-125">[Tests unitaires](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) implique le test d’une partie d’une application de manière isolée de son infrastructure et des dépendances.</span><span class="sxs-lookup"><span data-stu-id="dee0e-125">[Unit testing](https://docs.microsoft.com/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="dee0e-126">Lorsque la logique du contrôleur, seul le contenu d’une seule action de test unitaire est testé, pas le comportement de ses dépendances ou de l’infrastructure elle-même.</span><span class="sxs-lookup"><span data-stu-id="dee0e-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="dee0e-127">En tant qu’unité vous vos actions de contrôleur de test, assurez-vous que vous concentrer uniquement sur son comportement.</span><span class="sxs-lookup"><span data-stu-id="dee0e-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="dee0e-128">Un test unitaire de contrôleur évite des éléments tels que les [filtres](filters.md), [routage](../../fundamentals/routing.md), ou [liaison de modèle](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="dee0e-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="dee0e-129">En se concentrant sur la seule chose, les tests unitaires sont généralement simple à écrire et rapides à exécuter.</span><span class="sxs-lookup"><span data-stu-id="dee0e-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="dee0e-130">Un ensemble bien écrit de tests unitaires peut être exécuté souvent sans la quantité de surcharge.</span><span class="sxs-lookup"><span data-stu-id="dee0e-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="dee0e-131">Toutefois, les tests unitaires ne pas détecter les problèmes dans l’interaction entre les composants, qui est l’objectif de [test d’intégration](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="dee0e-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration testing](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="dee0e-132">Si vous écrivez des filtres personnalisés, itinéraires, etc., vous devez le test unitaire leur, mais pas dans le cadre de vos tests sur une action de contrôleur spécifique.</span><span class="sxs-lookup"><span data-stu-id="dee0e-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="dee0e-133">Ils doivent être testées de manière isolée.</span><span class="sxs-lookup"><span data-stu-id="dee0e-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="dee0e-134">[Créer et exécuter des tests unitaires avec Visual Studio](https://docs.microsoft.com/visualstudio/test/unit-test-your-code).</span><span class="sxs-lookup"><span data-stu-id="dee0e-134">[Create and run unit tests with Visual Studio](https://docs.microsoft.com/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="dee0e-135">Pour illustrer les tests unitaires, passez en revue le contrôleur suivant.</span><span class="sxs-lookup"><span data-stu-id="dee0e-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="dee0e-136">Il affiche la liste des sessions de réflexion et permet de nouvelles sessions sont créés avec une publication de réflexion :</span><span class="sxs-lookup"><span data-stu-id="dee0e-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="dee0e-137">Le contrôleur est après le [principe de dépendances explicites](http://deviq.com/explicit-dependencies-principle/), attendu de lui fournir une instance de l’injection de dépendance `IBrainstormSessionRepository`.</span><span class="sxs-lookup"><span data-stu-id="dee0e-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="dee0e-138">Cela rend relativement facile à tester à l’aide d’une infrastructure d’objets fictifs, tel que [Moq](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="dee0e-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="dee0e-139">Le `HTTP GET Index` méthode ne dispose d’aucune en boucle ou de création de branche et uniquement appelle une méthode.</span><span class="sxs-lookup"><span data-stu-id="dee0e-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="dee0e-140">Pour effectuer ce test `Index` (méthode), nous devons vérifier qu’un `ViewResult` est retourné, avec une `ViewModel` à partir du référentiel `List` (méthode).</span><span class="sxs-lookup"><span data-stu-id="dee0e-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="dee0e-141">Le `HomeController` `HTTP POST Index` (méthode) (illustré ci-dessus) devez vérifier :</span><span class="sxs-lookup"><span data-stu-id="dee0e-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="dee0e-142">La méthode d’action retourne une erreur demande incorrecte `ViewResult` avec les données appropriées lorsque `ModelState.IsValid` est`false`</span><span class="sxs-lookup"><span data-stu-id="dee0e-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="dee0e-143">Le `Add` méthode sur le référentiel est appelée et un `RedirectToActionResult` est retourné avec les arguments appropriés lorsque `ModelState.IsValid` a la valeur true.</span><span class="sxs-lookup"><span data-stu-id="dee0e-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="dee0e-144">État de modèle non valide peut être testé en ajoutant des erreurs à l’aide de `AddModelError` comme indiqué dans le premier test ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="dee0e-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="dee0e-145">Le premier test confirme lorsque `ModelState` n’est pas valide, le même `ViewResult` est retourné en tant que pour un `GET` demande.</span><span class="sxs-lookup"><span data-stu-id="dee0e-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="dee0e-146">Notez que le test ne tente pas de passer d’un modèle non valide.</span><span class="sxs-lookup"><span data-stu-id="dee0e-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="dee0e-147">Cela ne fonctionnera pas tout de même, car la liaison de modèle n’est pas en cours d’exécution (si un [test d’intégration](xref:mvc/controllers/testing#integration-testing) utiliserait la liaison de modèle exercice).</span><span class="sxs-lookup"><span data-stu-id="dee0e-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="dee0e-148">Dans ce cas, liaison de modèle n’est pas en cours de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="dee0e-149">Ces tests unitaires Testez uniquement le code dans la méthode d’action.</span><span class="sxs-lookup"><span data-stu-id="dee0e-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="dee0e-150">Le deuxième test vérifie que quand `ModelState` est valide, un nouveau `BrainstormSession` est ajouté (via le référentiel), et la méthode retourne un `RedirectToActionResult` avec les propriétés attendues.</span><span class="sxs-lookup"><span data-stu-id="dee0e-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="dee0e-151">Les appels factices qui ne sont pas appelés sont normalement ignoré, mais en appelant `Verifiable` à la fin de l’installation appel lui permet de le vérifier dans le test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="dee0e-152">Cette opération s’effectue avec l’appel à `mockRepo.Verify`, ce qui échoue au test si la méthode attendue n’a pas été appelée.</span><span class="sxs-lookup"><span data-stu-id="dee0e-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="dee0e-153">La bibliothèque Moq utilisée dans cet exemple permet de facilement permet de combiner des simulacres vérifiables, ou « stricts », avec des simulacres non vérifiable (également appelés « libres » mocks ou stubs).</span><span class="sxs-lookup"><span data-stu-id="dee0e-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="dee0e-154">En savoir plus sur [personnalisation du comportement fictifs avec Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="dee0e-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="dee0e-155">Un autre contrôleur dans l’application affiche les informations liées à une séance particulier.</span><span class="sxs-lookup"><span data-stu-id="dee0e-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="dee0e-156">Il inclut une logique pour traiter les valeurs d’id non valide :</span><span class="sxs-lookup"><span data-stu-id="dee0e-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[Main](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="dee0e-157">L’action du contrôleur a trois cas à tester, une pour chaque `return` instruction :</span><span class="sxs-lookup"><span data-stu-id="dee0e-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="dee0e-158">L’application expose les fonctionnalités comme web API (il s’agit d’une liste d’idées associé à une session de réflexion et une méthode pour ajouter de nouvelles idées à une session) :</span><span class="sxs-lookup"><span data-stu-id="dee0e-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="dee0e-159">Le `ForSession` méthode retourne une liste de `IdeaDTO` types.</span><span class="sxs-lookup"><span data-stu-id="dee0e-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="dee0e-160">Éviter de retourner les entités de votre domaine métier directement par le biais d’appels d’API, depuis la fréquence à laquelle ils incluent plus de données que le client API a besoin, et leur associent inutilement modèle de domaine interne de votre application avec l’API vous exposez à l’extérieur.</span><span class="sxs-lookup"><span data-stu-id="dee0e-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="dee0e-161">Mappage entre les entités de domaine et les types que vous revenez sur le réseau peut être effectuée manuellement (à l’aide de LINQ `Select` comme indiqué ici) ou à l’aide d’une bibliothèque, par exemple [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span><span class="sxs-lookup"><span data-stu-id="dee0e-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="dee0e-162">Les tests unitaires pour le `Create` et `ForSession` méthodes API :</span><span class="sxs-lookup"><span data-stu-id="dee0e-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="dee0e-163">Comme indiqué précédemment, pour tester le comportement de la méthode lorsque `ModelState` n’est pas valide, ajoutez une erreur de modèle au contrôleur en tant que partie du test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="dee0e-164">N’essayez pas de tester la liaison de modèle ou de la validation de modèle dans vos tests unitaires : tester simplement le comportement de votre méthode d’action une fois confronté à un particulier `ModelState` valeur.</span><span class="sxs-lookup"><span data-stu-id="dee0e-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="dee0e-165">Le deuxième test dépend de l’espace de stockage retournant null, donc le référentiel fictif est configuré pour retourner une valeur null.</span><span class="sxs-lookup"><span data-stu-id="dee0e-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="dee0e-166">Il est inutile de créer une base de données de test (dans la mémoire ou autre) et construire une requête qui retourne ce résultat - il peut être effectué dans une instruction unique comme indiqué.</span><span class="sxs-lookup"><span data-stu-id="dee0e-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="dee0e-167">Le dernier test vérifie que l’espace de stockage `Update` méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="dee0e-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="dee0e-168">Comme nous l’avons fait précédemment, le fictifs est appelée avec `Verifiable` et puis factices du référentiel `Verify` méthode est appelée pour vérifier que la méthode vérifiable a été exécutée.</span><span class="sxs-lookup"><span data-stu-id="dee0e-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="dee0e-169">Il n’est pas une responsabilité de test unitaire pour vous assurer que le `Update` méthode enregistré les données ; cela peut se faire avec un test d’intégration.</span><span class="sxs-lookup"><span data-stu-id="dee0e-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="dee0e-170">Tests d’intégration</span><span class="sxs-lookup"><span data-stu-id="dee0e-170">Integration testing</span></span>

<span data-ttu-id="dee0e-171">[Tests d’intégration](../../testing/integration-testing.md) est effectuée pour garantir correctement ensemble de modules distincts au sein de votre travail de l’application.</span><span class="sxs-lookup"><span data-stu-id="dee0e-171">[Integration testing](../../testing/integration-testing.md) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="dee0e-172">En règle générale, tout ce que vous pouvez tester avec un test unitaire, vous pouvez également tester avec un test d’intégration, mais l’inverse n’est pas vrai.</span><span class="sxs-lookup"><span data-stu-id="dee0e-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="dee0e-173">Toutefois, les tests d’intégration tendent à être beaucoup plus lent que les tests unitaires.</span><span class="sxs-lookup"><span data-stu-id="dee0e-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="dee0e-174">Par conséquent, il est préférable de tester ce que vous pouvez avec des tests unitaires et utilisez des tests d’intégration pour les scénarios qui impliquent plusieurs collaborateurs.</span><span class="sxs-lookup"><span data-stu-id="dee0e-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="dee0e-175">Bien qu’elles peuvent toujours être utiles, les objets factices sont rarement utilisées dans les tests d’intégration.</span><span class="sxs-lookup"><span data-stu-id="dee0e-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="dee0e-176">Dans les tests unitaires, objets factices sont un moyen efficace de contrôler le comportement de collaborateurs en dehors de l’unité en cours de test pour les besoins du test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="dee0e-177">Dans un test d’intégration, les collaborateurs réels sont utilisés pour vérifier que le sous-système complet ensemble fonctionne correctement.</span><span class="sxs-lookup"><span data-stu-id="dee0e-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="dee0e-178">État de l’application</span><span class="sxs-lookup"><span data-stu-id="dee0e-178">Application state</span></span>

<span data-ttu-id="dee0e-179">Un facteur important lorsque vous effectuez des tests d’intégration consiste à définir l’état de votre application.</span><span class="sxs-lookup"><span data-stu-id="dee0e-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="dee0e-180">Les tests doivent être exécutés indépendamment des autres, et par conséquent, chaque test doit commencer par l’application dans un état connu.</span><span class="sxs-lookup"><span data-stu-id="dee0e-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="dee0e-181">Si votre application n’utiliser une base de données de persistance, cela peut être pas un problème.</span><span class="sxs-lookup"><span data-stu-id="dee0e-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="dee0e-182">Toutefois, la plupart des applications réelles conservent leur état à un certain type de magasin de données, donc toutes les modifications apportées par un seul test peut affecter un autre test, sauf si le magasin de données est réinitialisé.</span><span class="sxs-lookup"><span data-stu-id="dee0e-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="dee0e-183">À l’aide de la fonction intégrée `TestServer`, il est très simple pour les applications ASP.NET Core hôte dans nos tests d’intégration, mais qui n’accorde pas nécessairement l’accès aux données qu’il utilisera.</span><span class="sxs-lookup"><span data-stu-id="dee0e-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="dee0e-184">Si vous utilisez une base de données réelle, une approche consiste à avoir à l’application de se connecter à une base de données de test, lequel vos tests peuvent accéder à et vérifiez est réinitialisé à un état connu avant l’exécution de chaque test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="dee0e-185">Dans cet exemple d’application, j’utilise prise en charge de InMemoryDatabase d’Entity Framework Core, donc impossible de me connecter simplement à ce dernier à partir de mon projet de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="dee0e-186">Au lieu de cela, j’ai exposer une `InitializeDatabase` méthode à partir de l’application `Startup` (classe), laquelle appeler au démarrage de l’application si elle se trouve dans le `Development` environnement.</span><span class="sxs-lookup"><span data-stu-id="dee0e-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="dee0e-187">Mes tests d’intégration automatiquement tirer parti de cela, que leur définir l’environnement `Development`.</span><span class="sxs-lookup"><span data-stu-id="dee0e-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="dee0e-188">Je n’ai pas à vous soucier de la réinitialisation de la base de données, dans la mesure où le InMemoryDatabase est réinitialisé chaque fois que l’application redémarre.</span><span class="sxs-lookup"><span data-stu-id="dee0e-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="dee0e-189">La `Startup` classe :</span><span class="sxs-lookup"><span data-stu-id="dee0e-189">The `Startup` class:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="dee0e-190">Vous verrez la `GetTestSession` méthode fréquemment utilisée dans les tests d’intégration ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="dee0e-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="dee0e-191">L’accès aux vues</span><span class="sxs-lookup"><span data-stu-id="dee0e-191">Accessing views</span></span>

<span data-ttu-id="dee0e-192">Chaque classe de test d’intégration configure le `TestServer` qui exécutera l’application ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="dee0e-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="dee0e-193">Par défaut, `TestServer` héberge l’application web dans le dossier dans lequel il est en cours d’exécution - dans ce cas, le dossier de projet de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="dee0e-194">Par conséquent, lorsque vous essayez d’actions qui retournent du contrôleur de test `ViewResult`, vous pouvez voir cette erreur :</span><span class="sxs-lookup"><span data-stu-id="dee0e-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="dee0e-195">Pour corriger ce problème, vous devez configurer la racine du contenu du serveur, afin de pouvoir localiser les affichages pour le projet en cours de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="dee0e-196">Pour cela, un appel à `UseContentRoot` dans le `TestFixture` (classe), illustré ci-dessous :</span><span class="sxs-lookup"><span data-stu-id="dee0e-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="dee0e-197">Le `TestFixture` classe est responsable de la configuration et la création la `TestServer`, paramétrage un `HttpClient` pour communiquer avec le `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="dee0e-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="dee0e-198">Chacune de l’intégration de tests utilise le `Client` propriété pour se connecter au serveur de test et effectuer une demande.</span><span class="sxs-lookup"><span data-stu-id="dee0e-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="dee0e-199">Dans le premier test ci-dessus, le `responseString` contient le rendu HTML à partir de la vue, qui peut être inspectée pour confirmer qu’il contient les résultats attendus.</span><span class="sxs-lookup"><span data-stu-id="dee0e-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="dee0e-200">Le deuxième test construit une publication de formulaire avec un nom de session unique et envoie à l’application, puis vérifie que la redirection attendue est retournée.</span><span class="sxs-lookup"><span data-stu-id="dee0e-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="dee0e-201">Méthodes de l’API</span><span class="sxs-lookup"><span data-stu-id="dee0e-201">API methods</span></span>

<span data-ttu-id="dee0e-202">Si votre application expose web API, il judicieux d’avoir des tests automatisés confirmer qu’ils s’exécutent comme prévu.</span><span class="sxs-lookup"><span data-stu-id="dee0e-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="dee0e-203">La fonction intégrée `TestServer` facilite l’API web de test.</span><span class="sxs-lookup"><span data-stu-id="dee0e-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="dee0e-204">Si vos méthodes de l’API sont à l’aide de liaison de modèle, vous devez toujours vérifier `ModelState.IsValid`, et les tests d’intégration sont au bon endroit pour confirmer le fonctionne de la validation de votre modèle.</span><span class="sxs-lookup"><span data-stu-id="dee0e-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="dee0e-205">L’ensemble de la cible de tests suivant le `Create` méthode dans le [IdeasController](xref:mvc/controllers/testing#ideas-controller) classe ci-dessus :</span><span class="sxs-lookup"><span data-stu-id="dee0e-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[Main](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="dee0e-206">Contrairement aux tests d’intégration d’actions qui retourne des vues HTML, les méthodes API web qui retournent des résultats peuvent généralement être désérialisés en tant qu’objets fortement typés, comme le montre le dernier test ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="dee0e-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="dee0e-207">Dans ce cas, le test désérialise le résultat à une `BrainstormSession` d’instance et confirme que l’idée a été correctement ajoutée à la collection des idées.</span><span class="sxs-lookup"><span data-stu-id="dee0e-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="dee0e-208">Vous trouverez des exemples supplémentaires de tests d’intégration dans cet article [exemple de projet](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span><span class="sxs-lookup"><span data-stu-id="dee0e-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
